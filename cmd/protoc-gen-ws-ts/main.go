// protoc-gen-ws-ts generates TypeScript WebSocket/yamux client stubs
// from protobuf service definitions.
//
// For each service it emits a typed client class that uses the yamux
// transport layer defined in client/ts/src/.
//
// Compatible with protobuf-es v2 (functional toBinary/fromBinary API).
package main

import (
	"flag"
	"fmt"
	"path"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	runtimeImport string
	streamingOnly bool
)

func main() {
	flags := flag.NewFlagSet("protoc-gen-ws-ts", flag.ContinueOnError)
	flags.StringVar(&runtimeImport, "runtime_import", "", "Import path for the ws runtime (required). Relative paths (starting with .) are adjusted for proto directory depth; package names are used verbatim.")
	flags.BoolVar(&streamingOnly, "streaming_only", false, "Only generate streaming RPCs (skip unary methods handled by Connect-RPC)")

	protogen.Options{ParamFunc: flags.Set}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		if runtimeImport == "" {
			return fmt.Errorf("protoc-gen-ws-ts: missing required option runtime_import")
		}
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if len(f.Services) == 0 {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// isStreaming returns true if the method is any streaming type (not unary).
func isStreaming(m *protogen.Method) bool {
	return m.Desc.IsStreamingClient() || m.Desc.IsStreamingServer()
}

// streamingMethods returns the subset of methods to generate.
// When streamingOnly is true, unary methods are excluded.
func streamingMethods(methods []*protogen.Method) []*protogen.Method {
	if !streamingOnly {
		return methods
	}
	var out []*protogen.Method
	for _, m := range methods {
		if isStreaming(m) {
			out = append(out, m)
		}
	}
	return out
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	// When streaming_only is set, check if any service has streaming methods.
	// If not, skip the entire file.
	if streamingOnly {
		hasStreaming := false
		for _, svc := range file.Services {
			if len(streamingMethods(svc.Methods)) > 0 {
				hasStreaming = true
				break
			}
		}
		if !hasStreaming {
			return
		}
	}

	// e.g. "v1/identity.proto" → baseName = "identity", dir = "v1"
	protoName := file.Proto.GetName()
	dir := path.Dir(protoName)
	base := strings.TrimSuffix(path.Base(protoName), ".proto")

	outPath := path.Join(dir, base+".ws.ts")

	g := gen.NewGeneratedFile(outPath, "")

	g.P("// Code generated by protoc-gen-ws-ts. DO NOT EDIT.")
	g.P("//")
	g.P("// Source: ", protoName)
	g.P()

	// Compute runtime import prefix from the runtime_import option.
	var srcPrefix string
	if strings.HasPrefix(runtimeImport, ".") {
		// Relative path mode: adjust for proto directory depth.
		// runtimeImport is relative to the output root (e.g. "../src").
		// The generated file sits at <out>/<dir>/, so we need to prepend
		// "../" for each directory level in <dir>.
		depth := strings.Count(dir, "/") + 1
		srcPrefix = strings.Repeat("../", depth) + runtimeImport
	} else {
		// Package name mode: use verbatim (e.g. "@myorg/protows").
		srcPrefix = runtimeImport
	}

	// Determine which transport symbols are needed.
	hasUnary := false
	hasStream := false
	for _, svc := range file.Services {
		for _, m := range streamingMethods(svc.Methods) {
			if m.Desc.IsStreamingClient() || m.Desc.IsStreamingServer() {
				hasStream = true
			} else {
				hasUnary = true
			}
		}
	}

	// Import yamux session type
	g.P("import type { YamuxSession } from \"", srcPrefix, "/yamux.js\";")

	// Build transport imports based on what's actually used.
	var transportImports []string
	if hasUnary {
		transportImports = append(transportImports, "callUnary")
	}
	if hasStream {
		transportImports = append(transportImports, "openStream")
	}
	// Collect stream class imports
	for _, svc := range file.Services {
		for _, m := range streamingMethods(svc.Methods) {
			cs := m.Desc.IsStreamingClient()
			ss := m.Desc.IsStreamingServer()
			switch {
			case !cs && ss:
				if !contains(transportImports, "ServerStream") {
					transportImports = append(transportImports, "ServerStream")
				}
			case cs && !ss:
				if !contains(transportImports, "ClientStream") {
					transportImports = append(transportImports, "ClientStream")
				}
			case cs && ss:
				if !contains(transportImports, "BidiStream") {
					transportImports = append(transportImports, "BidiStream")
				}
			}
		}
	}
	g.P("import { ", strings.Join(transportImports, ", "), " } from \"", srcPrefix, "/transport.js\";")

	// Import protobuf-es v2 functional API
	g.P("import { toBinary, fromBinary } from \"@bufbuild/protobuf\";")

	// Collect message types and schemas used by services
	types, schemas := collectImports(file)
	var imports []string
	for _, t := range types {
		imports = append(imports, "type "+t)
	}
	imports = append(imports, schemas...)
	if len(imports) > 0 {
		g.P("import { ", strings.Join(imports, ", "), " } from \"./", base, "_pb.js\";")
	}
	g.P()

	for _, svc := range file.Services {
		generateService(g, svc)
	}
}

// collectImports returns deduplicated type names and schema names from all services.
func collectImports(file *protogen.File) (types []string, schemas []string) {
	seenType := map[string]bool{}
	seenSchema := map[string]bool{}
	for _, svc := range file.Services {
		for _, m := range streamingMethods(svc.Methods) {
			for _, msg := range []*protogen.Message{m.Input, m.Output} {
				name := string(msg.Desc.Name())
				schema := name + "Schema"
				if !seenType[name] {
					seenType[name] = true
					types = append(types, name)
				}
				if !seenSchema[schema] {
					seenSchema[schema] = true
					schemas = append(schemas, schema)
				}
			}
		}
	}
	return
}

func generateService(g *protogen.GeneratedFile, svc *protogen.Service) {
	svcName := svc.GoName
	fullName := string(svc.Desc.FullName())
	methods := streamingMethods(svc.Methods)

	// If streaming_only is set and this service has no streaming methods, skip entirely.
	if streamingOnly && len(methods) == 0 {
		return
	}

	// Service name constant
	g.P("export const ", svcName, "Name = \"", fullName, "\";")
	g.P()

	// Method name constants
	for _, m := range methods {
		constName := svcName + string(m.Desc.Name()) + "Method"
		methodFQN := fullName + "/" + string(m.Desc.Name())
		g.P("export const ", constName, " = \"", methodFQN, "\";")
	}
	g.P()

	// Client class
	g.P("export class ", svcName, "WSClient {")
	g.P("  constructor(private session: YamuxSession) {}")
	g.P()

	for _, m := range methods {
		generateMethod(g, svc, m)
	}

	g.P("}")
	g.P()
}

func generateMethod(g *protogen.GeneratedFile, svc *protogen.Service, m *protogen.Method) {
	fullName := string(svc.Desc.FullName())
	methodFQN := fullName + "/" + string(m.Desc.Name())
	tsName := toCamelCase(string(m.Desc.Name()))
	inType := string(m.Input.Desc.Name())
	outType := string(m.Output.Desc.Name())
	inSchema := inType + "Schema"
	outSchema := outType + "Schema"

	cs := m.Desc.IsStreamingClient()
	ss := m.Desc.IsStreamingServer()

	switch {
	case !cs && !ss:
		// Unary
		g.P("  async ", tsName, "(req: ", inType, "): Promise<", outType, "> {")
		g.P("    return callUnary(")
		g.P("      this.session,")
		g.P("      \"", methodFQN, "\",")
		g.P("      toBinary(", inSchema, ", req),")
		g.P("      (b) => fromBinary(", outSchema, ", b),")
		g.P("    );")
		g.P("  }")

	case !cs && ss:
		// Server streaming
		g.P("  async ", tsName, "(req: ", inType, "): Promise<ServerStream<", outType, ">> {")
		g.P("    const stream = await openStream(this.session, \"", methodFQN, "\");")
		g.P("    await stream.send(toBinary(", inSchema, ", req));")
		g.P("    return new ServerStream(stream, (b) => fromBinary(", outSchema, ", b));")
		g.P("  }")

	case cs && !ss:
		// Client streaming
		g.P("  async ", tsName, "(): Promise<ClientStream<", inType, ", ", outType, ">> {")
		g.P("    const stream = await openStream(this.session, \"", methodFQN, "\");")
		g.P("    return new ClientStream(stream, (m) => toBinary(", inSchema, ", m), (b) => fromBinary(", outSchema, ", b));")
		g.P("  }")

	case cs && ss:
		// Bidi streaming
		g.P("  async ", tsName, "(): Promise<BidiStream<", inType, ", ", outType, ">> {")
		g.P("    const stream = await openStream(this.session, \"", methodFQN, "\");")
		g.P("    return new BidiStream(stream, (m) => toBinary(", inSchema, ", m), (b) => fromBinary(", outSchema, ", b));")
		g.P("  }")
	}
	g.P()
}

// toCamelCase converts PascalCase to camelCase (e.g. "CreateUser" → "createUser").
func toCamelCase(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}

func contains(ss []string, s string) bool {
	for _, v := range ss {
		if v == s {
			return true
		}
	}
	return false
}
