// protoc-gen-ws generates typed WebSocket/yamux handler interfaces and client
// stubs from protobuf service definitions.
//
// It mirrors the pattern used by protoc-gen-connect-go: for each service it
// produces a handler interface, a registration function, an unimplemented
// handler, a client interface, and a client constructor.
package main

import (
	"flag"
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

// Package-level import path constants.
var (
	contextPkg = protogen.GoImportPath("context")
	protoPkg   = protogen.GoImportPath("google.golang.org/protobuf/proto")
	wsPkg      protogen.GoImportPath
	yamuxPkg   = protogen.GoImportPath("github.com/hashicorp/yamux")
	errorsPkg  = protogen.GoImportPath("errors")
	fmtPkg     = protogen.GoImportPath("fmt")
)

var streamingOnly bool

func main() {
	var wsImport string
	flags := flag.NewFlagSet("protoc-gen-ws", flag.ContinueOnError)
	flags.StringVar(&wsImport, "ws_import", "", "Go import path for the ws runtime package (required)")
	flags.BoolVar(&streamingOnly, "streaming_only", false, "Only generate streaming RPCs (skip unary methods handled by Connect-RPC)")

	protogen.Options{ParamFunc: flags.Set}.Run(func(gen *protogen.Plugin) error {
		if wsImport == "" {
			return fmt.Errorf("protoc-gen-ws: missing required option ws_import")
		}
		wsPkg = protogen.GoImportPath(wsImport)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			if len(f.Services) == 0 {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// isStreaming returns true if the method is any streaming type (not unary).
func isStreaming(m *protogen.Method) bool {
	return m.Desc.IsStreamingClient() || m.Desc.IsStreamingServer()
}

// streamingMethods returns the subset of methods to generate.
// When streamingOnly is true, unary methods are excluded.
func streamingMethods(methods []*protogen.Method) []*protogen.Method {
	if !streamingOnly {
		return methods
	}
	var out []*protogen.Method
	for _, m := range methods {
		if isStreaming(m) {
			out = append(out, m)
		}
	}
	return out
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	// When streaming_only is set, check if any service has streaming methods.
	// If not, skip the entire file.
	if streamingOnly {
		hasStreaming := false
		for _, svc := range file.Services {
			if len(streamingMethods(svc.Methods)) > 0 {
				hasStreaming = true
				break
			}
		}
		if !hasStreaming {
			return
		}
	}

	baseName := file.Proto.GetName()
	baseName = baseName[:len(baseName)-len(".proto")]
	if idx := strings.LastIndex(baseName, "/"); idx >= 0 {
		baseName = baseName[idx+1:]
	}

	goPkg := string(file.GoPackageName)
	wsDir := goPkg + "ws"
	wsImportPath := string(file.GoImportPath) + "/" + wsDir

	dirPrefix := ""
	if idx := strings.LastIndex(string(file.GeneratedFilenamePrefix), "/"); idx >= 0 {
		dirPrefix = string(file.GeneratedFilenamePrefix)[:idx+1]
	}

	g := gen.NewGeneratedFile(
		dirPrefix+wsDir+"/"+baseName+".ws.go",
		protogen.GoImportPath(wsImportPath),
	)

	g.P("// Code generated by protoc-gen-ws. DO NOT EDIT.")
	g.P("//")
	g.P("// Source: ", file.Proto.GetName())
	g.P()
	g.P("package ", wsDir)
	g.P()

	for _, svc := range file.Services {
		generateService(g, file, svc)
	}
}

func generateService(g *protogen.GeneratedFile, _ *protogen.File, svc *protogen.Service) {
	svcName := svc.GoName
	fullName := string(svc.Desc.FullName())
	methods := streamingMethods(svc.Methods)

	// If streaming_only is set and this service has no streaming methods, skip entirely.
	if streamingOnly && len(methods) == 0 {
		return
	}

	// --- Constants ---
	g.P("const (")
	g.P("  // ", svcName, "Name is the fully-qualified name of the ", svcName, " service.")
	g.P("  ", svcName, "Name = ", fmt.Sprintf("%q", fullName))
	g.P(")")
	g.P()

	g.P("const (")
	for _, m := range methods {
		mfn := fullName + "/" + string(m.Desc.Name())
		g.P("  // ", svcName, m.GoName, "Method is the fully-qualified name of the ", svcName, "'s ", m.GoName, " RPC.")
		g.P("  ", svcName, m.GoName, "Method = ", fmt.Sprintf("%q", mfn))
	}
	g.P(")")
	g.P()

	// --- Handler interface ---
	g.P("// ", svcName, "WSHandler is a WebSocket handler for the ", fullName, " service.")
	g.P("type ", svcName, "WSHandler interface {")
	for _, m := range methods {
		cs := m.Desc.IsStreamingClient()
		ss := m.Desc.IsStreamingServer()
		switch {
		case !cs && !ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ", *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error)")
		case !cs && ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ", *", m.Input.GoIdent, ", *", wsPkg.Ident("ServerStream"), "[*", m.Output.GoIdent, "]) error")
		case cs && !ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ", *", wsPkg.Ident("ClientStream"), "[*", m.Input.GoIdent, "]) (*", m.Output.GoIdent, ", error)")
		case cs && ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ", *", wsPkg.Ident("BidiStream"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "]) error")
		}
	}
	g.P("}")
	g.P()

	// --- Register function ---
	g.P("// Register", svcName, "WS registers the ", svcName, " WS handler with the router.")
	g.P("func Register", svcName, "WS(router *", wsPkg.Ident("WSRouter"), ", svc ", svcName, "WSHandler) {")
	for _, m := range methods {
		mfn := fullName + "/" + string(m.Desc.Name())
		cs := m.Desc.IsStreamingClient()
		ss := m.Desc.IsStreamingServer()
		switch {
		case !cs && !ss:
			g.P("  router.Handle(", fmt.Sprintf("%q", mfn), ", func(ctx ", contextPkg.Ident("Context"), ", payload []byte) (", protoPkg.Ident("Message"), ", error) {")
			g.P("    req := new(", m.Input.GoIdent, ")")
			g.P("    if err := ", protoPkg.Ident("Unmarshal"), "(payload, req); err != nil {")
			g.P("      return nil, err")
			g.P("    }")
			g.P("    return svc.", m.GoName, "(ctx, req)")
			g.P("  })")
		case !cs && ss:
			g.P("  router.HandleStream(", fmt.Sprintf("%q", mfn), ", func(ctx ", contextPkg.Ident("Context"), ", stream *", wsPkg.Ident("Stream"), ") {")
			g.P("    data, err := stream.Recv()")
			g.P("    if err != nil {")
			g.P("      stream.SendError(err.Error())")
			g.P("      return")
			g.P("    }")
			g.P("    req := new(", m.Input.GoIdent, ")")
			g.P("    if err := ", protoPkg.Ident("Unmarshal"), "(data, req); err != nil {")
			g.P("      stream.SendError(err.Error())")
			g.P("      return")
			g.P("    }")
			g.P("    ss := ", wsPkg.Ident("NewServerStream"), "[*", m.Output.GoIdent, "](stream)")
			g.P("    if err := svc.", m.GoName, "(ctx, req, ss); err != nil {")
			g.P("      stream.SendError(err.Error())")
			g.P("    }")
			g.P("  })")
		case cs && !ss:
			g.P("  router.HandleStream(", fmt.Sprintf("%q", mfn), ", func(ctx ", contextPkg.Ident("Context"), ", stream *", wsPkg.Ident("Stream"), ") {")
			g.P("    cs := ", wsPkg.Ident("NewClientStream"), "[*", m.Input.GoIdent, "](stream, func() *", m.Input.GoIdent, " { return new(", m.Input.GoIdent, ") })")
			g.P("    resp, err := svc.", m.GoName, "(ctx, cs)")
			g.P("    if err != nil {")
			g.P("      stream.SendError(err.Error())")
			g.P("      return")
			g.P("    }")
			g.P("    stream.SendProto(resp)")
			g.P("  })")
		case cs && ss:
			g.P("  router.HandleStream(", fmt.Sprintf("%q", mfn), ", func(ctx ", contextPkg.Ident("Context"), ", stream *", wsPkg.Ident("Stream"), ") {")
			g.P("    bs := ", wsPkg.Ident("NewBidiStream"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "](stream, func() *", m.Input.GoIdent, " { return new(", m.Input.GoIdent, ") })")
			g.P("    if err := svc.", m.GoName, "(ctx, bs); err != nil {")
			g.P("      stream.SendError(err.Error())")
			g.P("    }")
			g.P("  })")
		}
	}
	g.P("}")
	g.P()

	// --- Unimplemented handler ---
	g.P("// Unimplemented", svcName, "WSHandler returns errors from all methods.")
	g.P("type Unimplemented", svcName, "WSHandler struct{}")
	g.P()
	for _, m := range methods {
		cs := m.Desc.IsStreamingClient()
		ss := m.Desc.IsStreamingServer()
		errMsg := fmt.Sprintf("%s.%s is not implemented", fullName, m.GoName)
		switch {
		case !cs && !ss:
			g.P("func (Unimplemented", svcName, "WSHandler) ", m.GoName, "(_ ", contextPkg.Ident("Context"), ", _ *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error) {")
			g.P("  return nil, ", errorsPkg.Ident("New"), "(", fmt.Sprintf("%q", errMsg), ")")
			g.P("}")
		case !cs && ss:
			g.P("func (Unimplemented", svcName, "WSHandler) ", m.GoName, "(_ ", contextPkg.Ident("Context"), ", _ *", m.Input.GoIdent, ", _ *", wsPkg.Ident("ServerStream"), "[*", m.Output.GoIdent, "]) error {")
			g.P("  return ", errorsPkg.Ident("New"), "(", fmt.Sprintf("%q", errMsg), ")")
			g.P("}")
		case cs && !ss:
			g.P("func (Unimplemented", svcName, "WSHandler) ", m.GoName, "(_ ", contextPkg.Ident("Context"), ", _ *", wsPkg.Ident("ClientStream"), "[*", m.Input.GoIdent, "]) (*", m.Output.GoIdent, ", error) {")
			g.P("  return nil, ", errorsPkg.Ident("New"), "(", fmt.Sprintf("%q", errMsg), ")")
			g.P("}")
		case cs && ss:
			g.P("func (Unimplemented", svcName, "WSHandler) ", m.GoName, "(_ ", contextPkg.Ident("Context"), ", _ *", wsPkg.Ident("BidiStream"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "]) error {")
			g.P("  return ", errorsPkg.Ident("New"), "(", fmt.Sprintf("%q", errMsg), ")")
			g.P("}")
		}
		g.P()
	}

	// --- Client interface ---
	g.P("// ", svcName, "WSClient is a WebSocket client for the ", fullName, " service.")
	g.P("type ", svcName, "WSClient interface {")
	for _, m := range methods {
		cs := m.Desc.IsStreamingClient()
		ss := m.Desc.IsStreamingServer()
		switch {
		case !cs && !ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ", *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error)")
		case !cs && ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ", *", m.Input.GoIdent, ") (*", wsPkg.Ident("ServerStreamClient"), "[*", m.Output.GoIdent, "], error)")
		case cs && !ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ") (*", wsPkg.Ident("ClientStreamClient"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "], error)")
		case cs && ss:
			g.P("  ", m.GoName, "(", contextPkg.Ident("Context"), ") (*", wsPkg.Ident("BidiStreamClient"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "], error)")
		}
	}
	g.P("}")
	g.P()

	// --- Client constructor ---
	uc := unexport(svcName) + "WSClient"
	g.P("// New", svcName, "WSClient constructs a WebSocket client for the ", fullName, " service.")
	g.P("func New", svcName, "WSClient(session *", yamuxPkg.Ident("Session"), ") ", svcName, "WSClient {")
	g.P("  return &", uc, "{session: session}")
	g.P("}")
	g.P()

	g.P("type ", uc, " struct {")
	g.P("  session *", yamuxPkg.Ident("Session"))
	g.P("}")
	g.P()

	for _, m := range methods {
		mfn := fullName + "/" + string(m.Desc.Name())
		cs := m.Desc.IsStreamingClient()
		ss := m.Desc.IsStreamingServer()
		switch {
		case !cs && !ss:
			g.P("func (c *", uc, ") ", m.GoName, "(ctx ", contextPkg.Ident("Context"), ", req *", m.Input.GoIdent, ") (*", m.Output.GoIdent, ", error) {")
			g.P("  data, err := ", wsPkg.Ident("CallUnary"), "(c.session, ", fmt.Sprintf("%q", mfn), ", req)")
			g.P("  if err != nil {")
			g.P("    return nil, err")
			g.P("  }")
			g.P("  resp := new(", m.Output.GoIdent, ")")
			g.P("  if err := ", protoPkg.Ident("Unmarshal"), "(data, resp); err != nil {")
			g.P("    return nil, ", fmtPkg.Ident("Errorf"), "(\"unmarshal response: %w\", err)")
			g.P("  }")
			g.P("  return resp, nil")
			g.P("}")
		case !cs && ss:
			g.P("func (c *", uc, ") ", m.GoName, "(ctx ", contextPkg.Ident("Context"), ", req *", m.Input.GoIdent, ") (*", wsPkg.Ident("ServerStreamClient"), "[*", m.Output.GoIdent, "], error) {")
			g.P("  stream, err := ", wsPkg.Ident("OpenStream"), "(ctx, c.session, ", fmt.Sprintf("%q", mfn), ")")
			g.P("  if err != nil {")
			g.P("    return nil, err")
			g.P("  }")
			g.P("  if err := stream.SendProto(req); err != nil {")
			g.P("    stream.Close()")
			g.P("    return nil, err")
			g.P("  }")
			g.P("  return ", wsPkg.Ident("NewServerStreamClient"), "[*", m.Output.GoIdent, "](stream, func() *", m.Output.GoIdent, " { return new(", m.Output.GoIdent, ") }), nil")
			g.P("}")
		case cs && !ss:
			g.P("func (c *", uc, ") ", m.GoName, "(ctx ", contextPkg.Ident("Context"), ") (*", wsPkg.Ident("ClientStreamClient"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "], error) {")
			g.P("  stream, err := ", wsPkg.Ident("OpenStream"), "(ctx, c.session, ", fmt.Sprintf("%q", mfn), ")")
			g.P("  if err != nil {")
			g.P("    return nil, err")
			g.P("  }")
			g.P("  return ", wsPkg.Ident("NewClientStreamClient"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "](stream, func() *", m.Output.GoIdent, " { return new(", m.Output.GoIdent, ") }), nil")
			g.P("}")
		case cs && ss:
			g.P("func (c *", uc, ") ", m.GoName, "(ctx ", contextPkg.Ident("Context"), ") (*", wsPkg.Ident("BidiStreamClient"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "], error) {")
			g.P("  stream, err := ", wsPkg.Ident("OpenStream"), "(ctx, c.session, ", fmt.Sprintf("%q", mfn), ")")
			g.P("  if err != nil {")
			g.P("    return nil, err")
			g.P("  }")
			g.P("  return ", wsPkg.Ident("NewBidiStreamClient"), "[*", m.Input.GoIdent, ", *", m.Output.GoIdent, "](stream, func() *", m.Output.GoIdent, " { return new(", m.Output.GoIdent, ") }), nil")
			g.P("}")
		}
		g.P()
	}
}

func unexport(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToLower(s[:1]) + s[1:]
}
